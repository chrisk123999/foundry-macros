{
  "type": "spell",
  "system": {
    "description": {
      "value": "<p>You create a 20-foot-radius sphere of poisonous, yellow-green fog centered on a point you choose within range. The fog spreads around corners. It lasts for the duration or until strong wind disperses the fog, ending the spell. Its area is heavily obscured.</p>\n<p>When a creature enters the spell's area for the first time on a turn or starts its turn there, that creature must make a Constitution saving throw. The creature takes 5d8 poison damage on a failed save, or half as much damage on a successful one. Creatures are affected even if they hold their breath or don't need to breathe.</p>\n<p>The fog moves 10 feet away from you at the start of each of your turns, rolling along the surface of the ground. The vapors, being heavier than air, sink to the lowest level of the land, even pouring down openings.</p>\n<p><strong>At Higher Levels.</strong> When you cast this spell using a spell slot of 6th level or higher, the damage increases by 1d8 for each slot level above 5th.</p>",
      "chat": "",
      "unidentified": ""
    },
    "source": "Basic Rules, Player's Handbook pg 222",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": 10,
      "units": "minute"
    },
    "target": {
      "value": 20,
      "width": null,
      "units": "ft",
      "type": "sphere"
    },
    "range": {
      "value": 120,
      "long": null,
      "units": "ft"
    },
    "uses": {
      "value": null,
      "max": "",
      "per": "",
      "recovery": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "other",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": ""
    },
    "damage": {
      "parts": [
        [
          "0",
          "poison"
        ]
      ],
      "versatile": "",
      "value": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "level": 5,
    "school": "con",
    "components": {
      "value": "",
      "vocal": true,
      "somatic": true,
      "material": false,
      "ritual": false,
      "concentration": true
    },
    "materials": {
      "value": "",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": true
    },
    "scaling": {
      "mode": "level",
      "formula": "1d8"
    }
  },
  "name": "Cloudkill",
  "flags": {
    "ddbimporter": {
      "id": 136226,
      "definitionId": 2030,
      "entityTypeId": 435869154,
      "dndbeyond": {
        "lookup": "classSpell",
        "class": "Wizard",
        "level": 20,
        "characterClassId": 116821711,
        "spellLevel": 5,
        "ability": "int",
        "mod": 5,
        "dc": 19,
        "cantripBoost": false,
        "overrideDC": false,
        "id": 136226,
        "entityTypeId": 435869154,
        "healingBoost": 0,
        "usesSpellSlot": true
      },
      "originalName": "Cloudkill",
      "sources": [
        {
          "sourceId": 1,
          "pageNumber": null,
          "sourceType": 2
        },
        {
          "sourceId": 2,
          "pageNumber": 222,
          "sourceType": 1
        }
      ],
      "tags": [
        "Damage"
      ],
      "version": "3.1.23",
      "effectsApplied": true,
      "importId": "TFMXddyn3Tv0WVyp",
      "effect": {
        "dice": "5d8[poison]",
        "damageType": "poison",
        "save": "con",
        "sequencerFile": "jb2a.fog_cloud.2.green"
      }
    },
    "spell-class-filter-for-5e": {
      "parentClass": "wizard"
    },
    "itemacro": {
      "macro": {
        "data": {
          "name": "Cloudkill",
          "type": "script",
          "scope": "global",
          "command": "if(!game.modules.get(\"ActiveAuras\")?.active) {\n  ui.notifications.error(\"ActiveAuras is not enabled\");\n  return;\n}\n\nconsole.warn(args)\n\nconst lastArg = args[args.length - 1];\n\nfunction getCantripDice(actor) {\n  const level = actor.type === \"character\" ? actor.system.details.level : actor.system.details.cr;\n  return 1 + Math.floor((level + 1) / 6);\n}\n\nasync function rollItemDamage(targetToken, itemUuid, itemLevel) {\n  const item = await fromUuid(itemUuid);\n  const caster = item.parent;\n  const ddbEffectFlags = item.flags.ddbimporter.effect;\n  const isCantrip = ddbEffectFlags.isCantrip;\n  const damageDice = ddbEffectFlags.dice;\n  const damageType = ddbEffectFlags.damageType;\n  const saveAbility = ddbEffectFlags.save;\n  const casterToken = canvas.tokens.placeables.find((t) => t.actor?.uuid === caster.uuid);\n  const scalingDiceArray = item.system.scaling.formula.split(\"d\");\n  const scalingDiceNumber = itemLevel - item.system.level;\n  const upscaledDamage =  isCantrip\n    ? `${getCantripDice(caster.data)}d${scalingDiceArray[1]}[${damageType}]`\n    : scalingDiceNumber > 0 ? `${scalingDiceNumber}d${scalingDiceArray[1]}[${damageType}] + ${damageDice}` : damageDice;\n\n  const workflowItemData = duplicate(item.data);\n  workflowItemData.system.target = { value: 1, units: \"\", type: \"creature\" };\n  workflowItemData.system.save.ability = saveAbility;\n  workflowItemData.system.components.concentration = false;\n  workflowItemData.system.level = itemLevel;\n  workflowItemData.system.duration = { value: null, units: \"inst\" };\n  workflowItemData.system.target = { value: null, width: null, units: \"\", type: \"creature\" };\n\n  setProperty(workflowItemData, \"flags.itemacro\", {});\n  setProperty(workflowItemData, \"flags.midi-qol\", {});\n  setProperty(workflowItemData, \"flags.dae\", {});\n  setProperty(workflowItemData, \"effects\", []);\n  delete workflowItemData._id;\n\n  const saveOnEntry = ddbEffectFlags.saveOnEntry;\n  console.warn(\"saveOnEntry\", {ddbEffectFlags, saveOnEntry});\n  if (saveOnEntry) {\n    const entryItem = new CONFIG.Item.documentClass(workflowItemData, { parent: caster });\n    console.warn(\"Saving item on entry\", {entryItem, targetToken});\n    const options = {\n      showFullCard: false,\n      createWorkflow: true,\n      targetUuids: [targetToken.document.uuid],\n      configureDialog: false,\n      versatile: false,\n      consumeResource: false,\n      consumeSlot: false,\n    };\n    await MidiQOL.completeItemRoll(entryItem, options);\n  } else {\n    const damageRoll = await new Roll(upscaledDamage).evaluate({ async: true });\n    if (game.dice3d) game.dice3d.showForRoll(damageRoll);\n\n    workflowItemData.name = `${workflowItemData.name}: Turn Entry Damage`;\n    // console.warn(\"workflowItemData\", workflowItemData);\n\n    await new MidiQOL.DamageOnlyWorkflow(\n      caster,\n      casterToken,\n      damageRoll.total,\n      damageType,\n      [targetToken],\n      damageRoll,\n      {\n        flavor: `(${CONFIG.DND5E.damageTypes[damageType]})`,\n        itemCardId: \"new\",\n        itemData: workflowItemData,\n        isCritical: false,\n      }\n    );\n  }\n\n}\n\nasync function attachSequencerFileToTemplate(templateUuid, sequencerFile, originUuid) {\n  if (game.modules.get(\"sequencer\")?.active) {\n    if (Sequencer.Database.entryExists(sequencerFile)) {\n      console.debug(\"Trying to apply sequencer effect\", {sequencerFile, templateUuid});\n      const template = await fromUuid(templateUuid);\n      new Sequence()\n      .effect()\n        .file(Sequencer.Database.entryExists(sequencerFile))\n        .size({\n          width: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n          height: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n        })\n        .persist(true)\n        .origin(originUuid)\n        .belowTokens()\n        .opacity(0.5)\n        .attachTo(template, { followRotation: true })\n        .stretchTo(template, { attachTo: true})\n      .play();\n    }\n  }\n}\n\nif (args[0].tag === \"OnUse\" && args[0].macroPass === \"preActiveEffects\") {\n  const safeName = lastArg.itemData.name.replace(/\\s|'|\\.|’/g, \"_\");\n  const dataTracker = {\n    randomId: randomID(),\n    targetUuids: lastArg.targetUuids,\n    startRound: game.combat.round,\n    startTurn: game.combat.turn,\n    spellLevel: lastArg.spellLevel,\n  };\n\n  const item = await fromUuid(lastArg.itemUuid);\n  await DAE.unsetFlag(item, `${safeName}Tracker`);\n  await DAE.setFlag(item, `${safeName}Tracker`, dataTracker);\n\n  const ddbEffectFlags = lastArg.item.flags.ddbimporter?.effect;\n\n  if (ddbEffectFlags) {\n    const sequencerFile = ddbEffectFlags.sequencerFile;\n    if (sequencerFile) {\n      attachSequencerFileToTemplate(lastArg.templateUuid, sequencerFile, lastArg.itemUuid)\n    }\n    if (ddbEffectFlags.isCantrip) {\n      const cantripDice = getCantripDice(lastArg.actor);\n      args[0].spellLevel = cantripDice;\n      ddbEffectFlags.cantripDice = cantripDice;\n      let newEffects = args[0].item.effects.map((effect) => {\n        effect.changes = effect.changes.map((change) => {\n          change.value = change.value.replace(\"@cantripDice\", cantripDice)\n          return change;\n        });\n        return effect;\n      });\n      args[0].item.effects = duplicate(newEffects);\n      args[0].itemData.effects = duplicate(newEffects);\n    }\n    const template = await fromUuid(lastArg.templateUuid);\n    await template.update({\"flags.effect\": ddbEffectFlags});\n  }\n\n  return await AAhelpers.applyTemplate(args);\n\n} else if (args[0] == \"on\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const item = await fromUuid(lastArg.efData.origin);\n  const targetItemTracker = DAE.getFlag(item.parent, `${safeName}Tracker`);\n  const originalTarget = targetItemTracker.targetUuids.includes(lastArg.tokenUuid);\n  const target = canvas.tokens.get(lastArg.tokenId);\n  const targetTokenTrackerFlag = DAE.getFlag(target, `${safeName}Tracker`);\n  const targetedThisCombat = targetTokenTrackerFlag && targetItemTracker.randomId === targetTokenTrackerFlag.randomId;\n  const targetTokenTracker = targetedThisCombat\n    ? targetTokenTrackerFlag\n    : {\n      randomId: targetItemTracker.randomId,\n      round: game.combat.round,\n      turn: game.combat.turn,\n      hasLeft: false,\n    };\n\n  const castTurn = targetItemTracker.startRound === game.combat.round && targetItemTracker.startTurn === game.combat.turn;\n  const isLaterTurn = game.combat.round > targetTokenTracker.round || game.combat.turn > targetTokenTracker.turn;\n\n  // if:\n  // not cast turn, and not part of the original target\n  // AND one of the following\n  // not original template and have not yet had this effect applied this combat OR\n  // has been targeted this combat, left and re-entered effect, and is a later turn\n  if (castTurn && originalTarget) {\n    console.debug(`Token ${target.name} is part of the original target for ${item.name}`);\n  } else if (!targetedThisCombat || (targetedThisCombat && targetTokenTracker.hasLeft && isLaterTurn)){\n    console.debug(`Token ${target.name} is targeted for immediate damage with ${item.name}, using the following factors`, { originalTarget, castTurn, targetedThisCombat, targetTokenTracker, isLaterTurn });\n    targetTokenTracker.hasLeft = false;\n    await rollItemDamage(target, lastArg.efData.origin, targetItemTracker.spellLevel);\n  }\n  await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n} else if (args[0] == \"off\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const target = canvas.tokens.get(lastArg.tokenId);\n  const targetTokenTracker = DAE.getFlag(target, `${safeName}Tracker`);\n\n  if (targetTokenTracker) {\n    targetTokenTracker.hasLeft = true;\n    targetTokenTracker.turn = game.combat.turn;\n    targetTokenTracker.round = game.combat.round;\n    await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n  }\n}\n"
        },
        "options": {},
        "apps": {},
        "compendium": null,
        "name": "Cloudkill",
        "type": "script",
        "scope": "global",
        "command": "console.log('Item Macro');\nlet template = canvas.scene.collections.templates.get(args[0].templateId);\nif (!template) return;\nlet spellLevel = args[0].spellLevel;\nlet spelldc = args[0].actor.system.attributes.spelldc;\nlet damageRoll = spellLevel + 'd8';\nlet effectData = {\n\t'label': 'Cloudkill',\n\t'icon': 'icons/magic/air/fog-gas-smoke-swirling-green.webp',\n\t'changes': [\n\t\t{\n\t\t'key': 'flags.midi-qol.OverTime',\n\t\t'mode': 5,\n\t\t'value': 'turn=start, rollType=save, saveAbility= con, saveDamage= halfdamage, saveRemove= false, saveMagic=true, damageType= poison, damageRoll= ' + damageRoll + ', saveDC = ' + spelldc,\n\t\t'priority': 20\n\t\t}\n\t],\n\t'origin': args[0].itemUuid,\n\t'duration': {seconds: 86400},\n\t'flags': {\n\t\t'effectmacro': {\n\t\t\t'onTurnStart': {\n            \"script\": \"let combatTurn = game.combat.round + '-' + game.combat.turn;\\nlet templateid = effect.flags.world.spell.cloudkill.templateid;\\ntoken.document.setFlag('world', `spell.cloudkill.${templateid}.turn`, combatTurn);\"\n          }\n\t\t},\n\t\t'world': {\n\t\t\t'spell': {\n\t\t\t\t'cloudkill': {\n\t\t\t\t\t'templateid': template.id,\n\t\t\t\t\t'spellLevel': spellLevel,\n\t\t\t\t\t'spelldc': spelldc\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nlet tokenList = [];\nfor (let i = 0; args[0].targets.length > i; i++) {\n\tlet otherToken = args[0].targets[i];\n\ttokenList.push(otherToken.id);\n\tlet otherActor = otherToken.actor;\n\tlet cloudEffect = otherActor.effects.find(eff => eff.label === 'Cloudkill');\n\tlet addEffect = true;\n\tif (cloudEffect) {\n\t\taddEffect = false;\n\t\tlet otherSpellLevel = cloudEffect.flags.world.spell.cloudkill.spellLevel;\n\t\tlet otherSpelldc = cloudEffect.flags.world.spell.cloudkill.spelldc;\n\t\tif (otherSpellLevel < spellLevel) {\n\t\t\taddEffect = true;\n\t\t\tawait MidiQOL.socket().executeAsGM(\"removeEffects\", {actorUuid: otherActor.uuid, effects: [cloudEffect.id]});\n\t\t} else if (otherSpellLevel === spellLevel && otherSpelldc < spelldc) {\n\t\t\taddEffect = true;\n\t\t\tawait MidiQOL.socket().executeAsGM(\"removeEffects\", {actorUuid: otherActor.uuid, effects: [cloudEffect.id]});\n\t\t}\n\t}\n\tif (addEffect) {\n\t\tawait MidiQOL.socket().executeAsGM(\"createEffects\", {actorUuid: otherActor.uuid, effects: [effectData]});\n\t}\n\t\n}\ntemplate.setFlag('world', 'spell.cloudkill', {spellLevel, spelldc, tokenList});\nconsole.log(template);",
        "author": "Ci2oCKdswvomgIrG",
        "_id": null,
        "img": "icons/svg/dice-target.svg",
        "folder": null,
        "sort": 0,
        "ownership": {
          "default": 0
        },
        "flags": {},
        "_stats": {
          "systemId": null,
          "systemVersion": null,
          "coreVersion": null,
          "createdTime": null,
          "modifiedTime": null,
          "lastModifiedBy": null
        }
      }
    },
    "midi-qol": {
      "onUseMacroName": "[postActiveEffects]ItemMacro",
      "effectActivation": false
    },
    "custom-character-sheet-sections": {
      "sectionName": ""
    },
    "rest-recovery": {
      "data": {
        "recovery": {
          "enabled": false
        }
      }
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false,
      "ignoreTotalCover": false
    },
    "enhanced-terrain-layer": {
      "multiple": null,
      "elevation": null,
      "depth": null,
      "environment": ""
    },
    "templatemacro": {
      "whenEntered": {
        "asGM": true,
        "command": "console.log('Processing Entered');\nfunction sleep(ms) {\n\treturn new Promise(resolve => setTimeout(resolve, ms));\n}\nawait sleep(10);\nlet doDamage = false;\nif (game.combat != null && game.combat != undefined) {\n\tlet combatTurn = game.combat.round + '-' + game.combat.turn;\n\tlet tokenTurn = token.document.getFlag('world', `spell.cloudkill.${template.id}.turn`);\n\tif (tokenTurn != combatTurn) doDamage = true;\n\ttoken.document.setFlag('world', `spell.cloudkill.${template.id}.turn`, combatTurn);\n} else {\n\tdoDamage = true;\n}\nlet spellLevel = template.flags.world.spell.cloudkill.spellLevel;\nlet spelldc = template.flags.world.spell.cloudkill.spelldc;\nlet damageRoll = spellLevel + 'd8';\nlet effectData = {\n\t'label': 'Cloudkill',\n\t'icon': 'icons/magic/air/fog-gas-smoke-swirling-green.webp',\n\t'changes': [\n\t\t{\n\t\t'key': 'flags.midi-qol.OverTime',\n\t\t'mode': 5,\n\t\t'value': 'turn=start, rollType=save, saveAbility= con, saveDamage= halfdamage, saveRemove= false, saveMagic=true, damageType= poison, damageRoll= ' + damageRoll + ', saveDC = ' + spelldc,\n\t\t'priority': 20\n\t\t}\n\t],\n\t'origin': template.flags.dnd5e.origin,\n\t'duration': {seconds: 86400},\n\t'flags': {\n\t\t'effectmacro': {\n\t\t\t'onTurnStart': {\n            \"script\": \"let combatTurn = game.combat.round + '-' + game.combat.turn;\\nlet templateid = effect.flags.world.spell.cloudkill.templateid;\\ntoken.document.setFlag('world', `spell.cloudkill.${templateid}.turn`, combatTurn);\"\n          }\n\t\t},\n\t\t'world': {\n\t\t\t'spell': {\n\t\t\t\t'cloudkill': {\n\t\t\t\t\t'templateid': template.id,\n\t\t\t\t\t'spellLevel': spellLevel,\n\t\t\t\t\t'spelldc': spelldc\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nlet tokenList = template.flags.world.spell.cloudkill.tokenList;\nif (!tokenList.includes(token.id)) {\n\ttokenList.push(token.id);\n}\ntemplate.setFlag('world', 'spell.cloudkill', {tokenList});\nlet cloudEffect = token.actor.effects.find(eff => eff.label === 'Cloudkill');\nlet addEffect = true;\nif (cloudEffect) {\n\tconsole.log('Token has effect already.');\n\taddEffect = false;\n\tlet otherSpellLevel = cloudEffect.flags.world.spell.cloudkill.spellLevel;\n\tlet otherSpelldc = cloudEffect.flags.world.spell.cloudkill.spelldc;\n\tif (otherSpellLevel < spellLevel) {\n\t\taddEffect = true;\n\t\tcloudEffect.delete();\n\t} else if (otherSpellLevel === spellLevel && otherSpelldc < spelldc) {\n\t\taddEffect = true;\n\t\tcloudEffect.delete();\n\t}\n}\nif (addEffect) {\n\tawait token.actor.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\n\tcloudEffect = token.actor.effects.find(eff => eff.label === 'Cloudkill');\n}\nif (doDamage) MidiQOL.doOverTimeEffect(token.actor, cloudEffect, true);"
      },
      "whenLeft": {
        "asGM": true,
        "command": "console.log('Processing Left');\nlet effect = token.actor.effects.find(eff => eff.label === 'Cloudkill');\nif (!effect) return;\nlet templateid = effect.flags.world.spell.cloudkill.templateid;\nif (templateid === template.id) effect.delete();"
      },
      "whenDeleted": {
        "asGM": true,
        "command": "console.log('Processing Deleted');\nlet tokenList = template.flags.world.spell.cloudkill.tokenList;\nif (tokenList.length === 0) return;\nfor (let i = 0; tokenList.length > i; i++) {\n\tlet tokenDoc = canvas.scene.tokens.get(tokenList[i]);\n\tif (!tokenDoc) continue;\n\tconsole.log(tokenDoc);\n\ttokenDoc.unsetFlag('world', 'spell.cloudkill.' + template.id);\n\tlet effect = tokenDoc.actor.effects.find(eff => eff.label === 'Cloudkill');\n\tif (!effect) return;\n\tlet templateid = effect.flags.world.spell.cloudkill.templateid;\n\tif (templateid === template.id) effect.delete();\n}"
      },
      "whenMoved": {
        "asGM": true,
        "command": "console.log('Processing When Moved');\nlet tokensInTemplate = game.modules.get('templatemacro').api.findContained(template);\nlet tokenList = template.flags.world.spell.cloudkill.tokenList;\nlet spellLevel = template.flags.world.spell.cloudkill.spellLevel;\nlet spelldc = template.flags.world.spell.cloudkill.spelldc;\nlet damageRoll = spellLevel + 'd8';\nlet effectData = {\n\t'label': 'Cloudkill',\n\t'icon': 'icons/magic/air/fog-gas-smoke-swirling-green.webp',\n\t'changes': [\n\t\t{\n\t\t'key': 'flags.midi-qol.OverTime',\n\t\t'mode': 5,\n\t\t'value': 'turn=start, rollType=save, saveAbility= con, saveDamage= halfdamage, saveRemove= false, saveMagic=true, damageType= poison, damageRoll= ' + damageRoll + ', saveDC = ' + spelldc,\n\t\t'priority': 20\n\t\t}\n\t],\n\t'origin': template.flags.dnd5e.origin,\n\t'duration': {seconds: 86400},\n\t'flags': {\n\t\t'effectmacro': {\n\t\t\t'onTurnStart': {\n\t\t\t\"script\": \"let combatTurn = game.combat.round + '-' + game.combat.turn;\\nlet templateid = effect.flags.world.spell.cloudkill.templateid;\\ntoken.document.setFlag('world', `spell.cloudkill.${templateid}.turn`, combatTurn);\"\n\t\t  }\n\t\t},\n\t\t'world': {\n\t\t\t'spell': {\n\t\t\t\t'cloudkill': {\n\t\t\t\t\t'templateid': template.id,\n\t\t\t\t\t'spellLevel': spellLevel,\n\t\t\t\t\t'spelldc': spelldc\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nfor (let i = 0; tokenList.length > i; i++) {\n\tif (tokensInTemplate.includes(tokenList[i])) continue;\n\tlet tokenDoc = canvas.scene.tokens.get(tokenList[i]);\n\tlet effect = tokenDoc.actor.effects.find(eff => eff.label === 'Cloudkill');\n\tif (!effect) continue;\n\tlet templateid = effect.flags.world.spell.cloudkill.templateid;\n\tif (templateid === template.id) effect.delete();\n}\nfor (let i = 0; tokensInTemplate.length > i; i++) {\n\tlet tokenDoc = canvas.scene.tokens.get(tokensInTemplate[i]);\n\tif (game.combat != null && game.combat != undefined) {\n\t\tlet combatTurn = game.combat.round + '-' + game.combat.turn;\n\t\ttokenDoc.document.setFlag('world', `spell.cloudkill.${template.id}.turn`, combatTurn);\n\t}\n\tlet cloudEffect = tokenDoc.actor.effects.find(eff => eff.label === 'Cloudkill');\n\tlet addEffect = true;\n\tif (cloudEffect) {\n\t\taddEffect = false;\n\t\tlet otherSpellLevel = cloudEffect.flags.world.spell.cloudkill.spellLevel;\n\t\tlet otherSpelldc = cloudEffect.flags.world.spell.cloudkill.spelldc;\n\t\tif (otherSpellLevel < spellLevel) {\n\t\t\taddEffect = true;\n\t\t\tcloudEffect.delete();\n\t\t} else if (otherSpellLevel === spellLevel && otherSpelldc < spelldc) {\n\t\t\taddEffect = true;\n\t\t\tcloudEffect.delete();\n\t\t}\n\t}\n\tif (addEffect) {\n\t\tawait tokenDoc.actor.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\n\t}\n\tif (!tokenList.includes(tokenDoc.id)) {\n\t\ttokenList.push(tokenDoc.id);\n\t}\n}\ntemplate.setFlag('world', 'spell.cloudkill', {tokenList});"
      },
      "whenStaying": {
        "asGM": true,
        "command": "console.log('Processing When Staying');\nfunction sleep(ms) {\n\treturn new Promise(resolve => setTimeout(resolve, ms));\n}\nawait sleep(20);\nlet doDamage = false;\nif (game.combat != null && game.combat != undefined) {\n\tlet combatTurn = game.combat.round + '-' + game.combat.turn;\n\tlet tokenTurn = token.document.getFlag('world', `spell.cloudkill.${template.id}.turn`);\n\tif (tokenTurn != combatTurn) doDamage = true;\n\ttoken.document.setFlag('world', `spell.cloudkill.${template.id}.turn`, combatTurn);\n} else {\n\tdoDamage = true;\n}\nlet spellLevel = template.flags.world.spell.cloudkill.spellLevel;\nlet spelldc = template.flags.world.spell.cloudkill.spelldc;\nlet damageRoll = spellLevel + 'd8';\nlet effectData = {\n\t'label': 'Cloudkill',\n\t'icon': 'icons/magic/air/fog-gas-smoke-swirling-green.webp',\n\t'changes': [\n\t\t{\n\t\t'key': 'flags.midi-qol.OverTime',\n\t\t'mode': 5,\n\t\t'value': 'turn=start, rollType=save, saveAbility= con, saveDamage= halfdamage, saveRemove= false, saveMagic=true, damageType= poison, damageRoll= ' + damageRoll + ', saveDC = ' + spelldc,\n\t\t'priority': 20\n\t\t}\n\t],\n\t'origin': template.flags.dnd5e.origin,\n\t'duration': {seconds: 86400},\n\t'flags': {\n\t\t'effectmacro': {\n\t\t\t'onTurnStart': {\n            \"script\": \"let combatTurn = game.combat.round + '-' + game.combat.turn;\\nlet templateid = effect.flags.world.spell.cloudkill.templateid;\\ntoken.document.setFlag('world', `spell.cloudkill.${templateid}.turn`, combatTurn);\"\n          }\n\t\t},\n\t\t'world': {\n\t\t\t'spell': {\n\t\t\t\t'cloudkill': {\n\t\t\t\t\t'templateid': template.id,\n\t\t\t\t\t'spellLevel': spellLevel,\n\t\t\t\t\t'spelldc': spelldc\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nlet tokenList = template.flags.world.spell.cloudkill.tokenList;\nif (!tokenList.includes(token.id)) {\n\ttokenList.push(token.id);\n}\ntemplate.setFlag('world', 'spell.cloudkill', {tokenList});\nlet cloudEffect = token.actor.effects.find(eff => eff.label === 'Cloudkill');\nlet addEffect = true;\nif (cloudEffect) {\n\tconsole.log('Token has effect already.');\n\taddEffect = false;\n\tdoDamage = false;\n\tlet otherSpellLevel = cloudEffect.flags.world.spell.cloudkill.spellLevel;\n\tlet otherSpelldc = cloudEffect.flags.world.spell.cloudkill.spelldc;\n\tif (otherSpellLevel < spellLevel) {\n\t\taddEffect = true;\n\t\tcloudEffect.delete();\n\t} else if (otherSpellLevel === spellLevel && otherSpelldc < spelldc) {\n\t\taddEffect = true;\n\t\tcloudEffect.delete();\n\t}\n}\nif (addEffect) {\n\tawait token.actor.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\n\tcloudEffect = token.actor.effects.find(eff => eff.label === 'Cloudkill');\n}\nif (doDamage) MidiQOL.doOverTimeEffect(token.actor, cloudEffect, true);"
      }
    },
    "favtab": {
      "isFavorite": true
    },
    "core": {
      "sourceId": "Actor.iDTsfmjce9HF9WmK.Item.ELsVomopMwIhXcWT"
    },
    "exportSource": {
      "world": "wordal",
      "system": "dnd5e",
      "coreVersion": "10.290",
      "systemVersion": "2.0.3"
    }
  },
  "effects": [
    {
      "label": "Cloudkill - Movement Handler",
      "icon": "icons/magic/air/fog-gas-smoke-swirling-green.webp",
      "changes": [],
      "transfer": false,
      "_id": "px3PouJU5iD1zz5L",
      "disabled": false,
      "duration": {
        "startTime": null,
        "seconds": null,
        "combat": null,
        "rounds": null,
        "turns": null,
        "startRound": null,
        "startTurn": null
      },
      "origin": null,
      "tint": null,
      "flags": {
        "dae": {
          "selfTarget": false,
          "selfTargetAlways": true,
          "stackable": "none",
          "durationExpression": "",
          "macroRepeat": "none",
          "specialDuration": []
        },
        "core": {
          "statusId": ""
        },
        "ActiveAuras": {
          "isAura": false,
          "aura": "None",
          "radius": null,
          "alignment": "",
          "type": "",
          "ignoreSelf": false,
          "height": false,
          "hidden": false,
          "displayTemp": false,
          "hostile": false,
          "onlyOnce": false
        }
      }
    }
  ],
  "img": "icons/magic/air/fog-gas-smoke-swirling-green.webp",
  "_stats": {
    "systemId": "dnd5e",
    "systemVersion": "2.0.3",
    "coreVersion": "10.290",
    "createdTime": 1667888110992,
    "modifiedTime": 1668293656703,
    "lastModifiedBy": "Ci2oCKdswvomgIrG"
  }
}